<!-- prettier-ignore-start -->
# API Guidelines

## Введение

Программная архитектура цифровой трансформации Сибур построена вокруг слабо связанных микросервисов, которые предоставляют 
функциональность с помощью API. Проектные команды, владеют, разрабатывают, развертывают и поддерживают эти микросервисы.
API микросервисов максимально полно отражают свою функциональность. Разработка качественных, долговечных и производительных API, 
является приоритетной задачей.

API First является одним из наших ключевых принципов проектирования. Разработка микросервисов начинается с проектирования API.
Что в идеале включает в себя обширную обратную связь от клиентов API для получения высококачественных API-интерфейсов. 
API First включает в себя набор стандартов описанных в данном документе и поддерживает культуру коллегиального обзора. 
Мы призываем наши команды следовать им, чтобы гарантировать, что наши API:
- можно легко и быстро понять
- просты в использовании
- следуют единому стилю
- совместимы с API других команд и нашей глобальной архитектурой

В идеале все API-интерфейсы должны выглядеть так, как будто их создал один и тот же автор.

## Соглашения используемые в документе

Ключевые слова используемые для указания уровня требований должны быть интерпретированы как в [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt):
- ДОЛЖЕН, ТРЕБУЕТСЯ, ОБЯЗАН ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 1)
- НЕ ДОЛЖЕН, НЕ ТРЕБУЕТСЯ, НЕ ОБЯЗАН ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 2)
- РЕКОМЕНДУЕТСЯ ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 3)
- НЕ РЕКОМЕНДУЕТСЯ  ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 4)
- МОЖЕТ, ОПЦИОНАЛЬНО ([RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) пункт 5)

Данные слова используются напрямую в тексте, в любом регистре и допускаются различные окончания и другие способы словообразования.
Всё это не изменяет интерпретацию ключевых слов.

## Specific information

Цель документа "API Guidelines" в том, чтобы определить стандарты по разработке API, 
чтобы придать всем API "единый стиль и общий дух". Владельцами данного документа является представители различных проектных команд,
входящих в команду [API Guild](https://github.com/orgs/sibur/teams/api-guild),
его изменение проводится на основе голосования всеми участниками [API Guild](https://github.com/orgs/sibur/teams/api-guild). 
Решения о внесении изменений вносятся только с полного согласия с изменениями всех участников команды [API Guild](https://github.com/orgs/sibur/teams/api-guild),
то есть либо с изменением согласны все, либо оно отвергается.
 
Команды обязаны соблюдать данный документ во время разработки API. Любая команда может внести свой вклад в разработку руководящих принципов создав Pull request.
Рассмотрение, принятие или отклонение изменений внесенных в Pull request находится в компетенции команды [API Guild](https://github.com/orgs/sibur/teams/api-guild).

Эти руководящие принципы в какой-то мере будут изменяться и развиваться в процессе нашей работы, но команды могут уверенно следовать им и доверять им.

В случае когда API изменилось, следующие правила применяются:

- существующие API не обязаны изменяться, но это рекомендуется
- новые версии существующих API должны следовать новым правилам
- все общие API должны следовать новым правилам
- Новые API обязаны следовать новым правилам

При разработке API, любого микросервиса, разработчик обязан руководствоваться данными методическими
указаниями.

В качестве примера API, которое максимально следует данным рекомендациям в папке example содержится API, 
при разработке API с нуля рекомендуется брать данный шаблон за основу.

## Major principles
- API as a product: API должно разрабатываться так, как если бы оно могло бы быть открытым неопределенному
кругу лиц и могло бы решать их проблемы как целостный продукт.
- API first:  при разработке любого  микросервиса, с которым подразумевается внешнее взаимодействие,
разработка API является первичной и приоритетной.
- GRPC API Only: для описания API любого микросервиса должен использоваться 
только [GRPC](https://grpc.io/) интерфейс взаимодействия с ним, 
само API описывается с помощью [protocol-buffers proto3](https://developers.google.com/protocol-buffers/docs/proto3).
- One API for one microservice: любой  микросервис, должен иметь одно и только одно GRPC API,
и каждое API может быть реализовано только одним микросервисом.
- REST, We Can: в случаях, когда необходим REST API, требуется использовать [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway),
а не реализовывать REST интерфейс микросервиса отдельно. Если REST API реализовано, должно быть сгенерировано его Swagger-описание.
- Metadata it: метаданные могут и должны использоваться в случаях, когда это оправдано (в авторизации, версионировании, кэшировании, проксировании, реализации сквозных id запросов и т.п.).
- Self-documenting API:  содержимое proto файлов должно быть прокомментировано до такой степени, чтобы было
полностью понятно, без дополнительной документации, стороннему клиенту.

## API Repository
- Для хранения исходных кодов API используется VCS GIT
- Все репозитории с API Должны храниться в [gitlab](https://gitlab.com/sibur/api) 
- Любой клиент который использует API подключает репозиторий как git submodule
- Любой клиент следит за обновлениями репозитория API и самостоятельно обновляет submodule
- При обновлении версии пользователи, подписанные на изменения, уведомляются (через почту, Slack или любой другой автоматизированный канал)
- В названии можно использовать только нижний регистр, слова разделять с помощью - (hyphen)
- Имя репозитория API должно быть уникальным в рамках [gitlab](https://gitlab.com/sibur/api) 
- В имени репозитория не допускается использовать любые зарезервированные слова для любых языков
программирования
- В имени репозитория не допускается добавлять какие угодно префиксы или постфиксы, для отражения каких
угодно особенностей API, в.т.ч. private, public, external, internal, stable, dev, production и.т.п.

# Версионирование API
- До начала промышленной эксплуатации API версионируется по semver как нестабильный API (начиная с 0.0.1 или 0.1.0). В этом случае оно может изменяться без предупреждения.
- После начала эксплуатации API версионируется с помощью [семантического версионирования](https://semver.org/lang/ru/)
- Версионирование реализуется с помощью тегирования средствами Git master ветки в [gitlab](https://gitlab.com/sibur/api). 
- После начала эксплуатации API получает версию 1.0.0
- Изменения в API ниже major-версии не могут быть несовместимыми.
- Не должно использоваться версионирование в URI
- Для версионирования используются GRPC / HTTP заголовки (headers).
- Все изменения в API после версии 1.0.0 отражаются в CHANGELOG, заинтересованные пользователи получают уведомления об изменении версии.

# Repository structure
- Любой репозиторий с API в корне должен содержать файлы README.md, DOCUMENTATION.md CHANGELOG.md,.gitignore и папку proto
- Папка proto должна содержать файл domain.proto
- Папка proto не должна содержать файлов кроме domain.proto

# README.md content
- должен содержать описание предметной области и то какую задачу решает API
- должен содержать глоссарий с определением всех терминов предметной области, которые используются в API
- должен содержать ссылку на DOCUMENTATION.md
- должен содержать ссылку на CHANGELOG.md

# DOCUMENTATION.md content
- должен содержать автоматически сгенерированную документацию на основе domain.proto
- документация должна генерироваться с помощью [protoc-gen-doc](https://github.com/pseudomuto/protoc-gen-doc)

# CHANGELOG.md content
- должен содержать список изменений API от версии к версии в обратном хронологическом порядке (самое новое - в начале)
- должен обновляться одновременно с выпуском каждой новой версии API начиная с 1.0.0

# API Host and port
- данные правила действуют до начала промышленной эксплуатации API. До начала промышленной эксплуатации они должны быть пересмотрены.
- GRPC сервер микросервиса реализующий API должен быть доступен по следующему хосту:
{{repository-name}}.api.sibur.io, где {{repository-name}} идентично имени репозитория в [gitlab](https://gitlab.com/sibur/api),
- GRPC сервер микросервиса должен слушать порт 6565
- на домене api.sibur.io до начала промышленной эксплуатации, располагается staging экосистема микросервисов, в дальнейшем, возможно, 
потребуется пересмотр данного пункта

## Code Style rules

- API должно следовать следующему [code style](https://developers.google.com/protocol-buffers/docs/style)
- для отступов должна использоваться табуляция, 1 табуляция равна 4 пробелам
- все rpc отделяются друг от друга одной строкой
- для комментирования должна использоваться // нотация
- все комментарии пишутся перед комментируемой сущностью, на отдельной строке
- все message, enum и service отделяются друг от друга одной строкой
- все параметры внутри message и enum отделяются друг от друга отступом в одну строку
- service должны именоваться в UpperCamelCase
- message должны именоваться в UpperCamelCase
- rpc должны именоваться в lowerCamelCase
- param должны именоваться в lower_snake_case
- enum должны именоваться в UpperCamelCase
- enum param должны именоваться в SCREAMING_SNAKE_CASE

# domain.proto content and rules
- Апи должно быть написано на английском, за исключением комментариев
- Комментарии должны быть написаны либо на русском либо на английском
- domain.proto должен включать в себя все предметную область API
- На первой строчке domain.proto должно содержаться указание syntax= 'proto3';
- на второй строчке должен быть указан package, после него отступ в одну строчку
- В имени пакета должен использоваться UpperCamelCase
- Для именования репозитория используется следующий шаблон: Api.Sibur.{{repositoryName}}
- не допускается использования import, за исключением: import "google/api/annotations.proto"; 
(данное требование связано с наличием в некоторых инструментах grpc-ecosystem багов, 
при использовании import, в частности [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) 
не верно расставляет package для сгенерированных файлов при использовании import, 
в следствии чего его становится невозможно использовать)
- остальную часть файла занимают описания непосредственно API в следующем порядке: 
сначала идет объявление message модели предметной области,
 затем сервис, который отвечает за манипуляции с этой моделью,
  затем контейнер для request и response для сервиса, затем следующая модель итп.
- В конце файла должен находиться message Structures, который содержит общие для всего API структуры данных. 

## Model message rules 
- под моделью понимается message, который является сущностью предметной области
- название модели должно быть существительным, однозначным и отражать сущность предметной области
- название модели не должно содержать зарезервированные слова для языков  программирования
- название модели не должно содержать какие угодно префиксы или постфиксы, для отражения каких
угодно особенностей, в.т.ч. private, public, external, internal, stable, dev, production, test, entity и.т.п.
- модель должна содержать внутри себя message Id, в котором задается уникальный ключ этой модели
- первое поле модели должен быть Id id = 1;
- Модели которые содержат связи с другими моделями должны связываться с ними через их Id, 
а не содержать саму структуру модели с которой есть связь
- Модель может содержать message Data, в данном message хранятся параметры, 
которые нужно указывать при создании модели с помощью метода create,
 а также те, которые можно свободно изменять методом update
 
## Service rules 
- Каждый service должен отвечать за одну и только одну модель предметной области
- Имя service формируется по шаблону {{Model}}Service
- Название rpc процедуры должно быть глаголом, отражающем суть выполняемой операции
- В названии rpc процедуры не должно дублироваться имя сервиса или его части
- Если сервис предполагает CRUD операции, то он должен содержать их с следующими именами: get, create, update, delete
- Все rpc кроме get, create, update, delete должны быть прокомментированы
- Все rpc на вход получают request из соответствующего сервису пакета
- Все rpc на выход возвращают response из соответствующего сервису пакета
- Каждая rpc должна содержать option для описания в REST
- Для описания REST методов используется google.api.http
- В качестве pattern должен использоваться только post
- путь в post указывается по следующему шаблону "/{{model}}/{{rpc}}", где model - имя модели предметной области, 
rpc - название rpc метода, UpperCamelCase и lowerCamelCase в названиях message и rpc заменяются на kebab-case
- В качестве body всегда указывается "*"
- Более сложные маппинги в рамках [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) не должны использоваться
- Маппинги на путь в post параметров запроса не должны использоваться
- Авторизация пользователей осуществляется через заголовки GRPC / HTTP (authorization / Authorization)

## Packet rules
- message с постфиксом в имени Packet должен хранить все Request и Response для одного service
- данный message именуется по принципу {{Model}}Packet 
- packet не должен содержать request и response других сервисов
- message с постфиксом в имени Packet не должен хранить другие message, кроме Request и Response 

## Request rules
- Все Request должны именоваться по принципу {{RpcName}}Request
- Рекомендуется делать Request максимально простым для клиента

## Response rules
- Все Response должны именоваться по принципу {{RpcName}}Response
- Все Response должны содержать oneof параметр result, где внутри результат выполнения команды или enum Error message
- Error должен быть enum и содержать список всех возможных ошибок
- Error должен в качестве первого элемента enum содержать INTERNAL_ERROR,
данная ошибка включает в себя любую не категоризированную или не учтенную ошибку
- Error должен в качестве второго элемента enum содержать FORBIDDEN, данная ошибка говорит о том, 
что пользователь не прошел аутентификацию или авторизацию
- результат выполнения команды может быть в любом удобном для клиента виде, 
но рекомендуется возвращать хотя бы модель предметной области, над которой проводились изменения

## Get Request и Response
- Запрос на получение списка модели предметной области должен быть сформирован по следующему шаблону:
```proto
syntax="proto3";
message GetRequest {
    repeated Scope scope = 2;
    uint64 offset = 3;
    uint64 length = 4;

    message Scope {
        oneof condition {
            ById by_id = 1;
            LikeFullName like_full_name = 2;
        }

        message ById {
            repeated SomeModel.Id id = 1;
        }

        message LikeFullName {
            string full_name = 1;
        }
    }
}
```
- GetRequest может быть полностью пустым, если дополнительные условия поиска не предполагаются
- message Scope содержит список условий к которые применяются к выборке
- допускается использовать как несколько условий, так и не использовать их вовсе
- message Scope должен содержать oneof condition внутри которого указываются предикаты условий
- В качестве предикатов выступают message внутри Scope, каждое из которых указывает какое-то конкретное условие
- Третьим параметром GetRequest должен идти uint64 offset, который указывает сдвиг выборки с начала до значения offset
- Четвертым параметром GetRequest должен идти uint64 length, который указывает максимальную длину выборки
- GetResponse должен быть сформирован по следующему шаблону: 
```proto
syntax="proto3";
message GetResponse {
        oneof result {
            Batch batch = 1;
            Error error = 2;
        }

        enum Error {
            INTERNAL_ERROR = 0;
            FORBIDDEN = 1;
            INVALID_SCOPE_CONDITION = 2;
        }

        message Batch {
            repeated SomeModel some_model = 1;
        }
    }
```
- oneof result в GetResponse должен содержать Batch, внутри которого содержится результат выборки, 
а именно модели предметной области

## Structures rules
- в конце файла domain.proto должен быть message Structures
- В данном message определяются message, которые могут использоваться всеми другими message

## Работа с временем
- для передачи метки времени между сервером и клиентов, должно осуществляться только с  помощью следующего message:
```proto
syntax="proto3";
    // Описания момента во времени. Определяется как количество милисекунд,
    // прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (четверг)
    message Timestamp {
        // количество милисекунд, прошедших c 00:00:00 UTC 01.01.1970
        int64 milliseconds = 1;
    }
```

## Изменение документа

После принятия данного документа ему присваивается версия 1.0.0 и дальнейшее версионирование и обновление осуществляется по semver.
Изменения в документе после версии 1.0.0 описываются в файле CHANGELOG.md

<!-- prettier-ignore-end -->
